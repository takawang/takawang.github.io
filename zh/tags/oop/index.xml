<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>OOP on Liberation Notes</title>
    <link>https://blog2.cmwang.net/zh/tags/oop/</link>
    <description>Recent content in OOP on Liberation Notes</description>
    <image>
      <title>Liberation Notes</title>
      <url>https://blog2.cmwang.net/47</url>
      <link>https://blog2.cmwang.net/47</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Fri, 16 Oct 2020 14:25:53 +0800</lastBuildDate>
    <atom:link href="https://blog2.cmwang.net/zh/tags/oop/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PHP 物件導向 (上)</title>
      <link>https://blog2.cmwang.net/zh/posts/2020/10/php-oop-part1/</link>
      <pubDate>Fri, 16 Oct 2020 14:25:53 +0800</pubDate>
      <guid>https://blog2.cmwang.net/zh/posts/2020/10/php-oop-part1/</guid>
      <description>PHP 物件導向上半部</description>
      <content:encoded><![CDATA[<h3 id="魔術方法-magic-methods">魔術方法 (Magic Methods)</h3>
<p>魔術方法是在類別中具有特殊名稱的方法，它們在特定的時機被自動呼叫，這些時機通常與類別的操作和生命週期相關。一個常用的魔術方法是建構子（Constructor）。</p>
<h4 id="建構子-constructor">建構子 (Constructor)</h4>
<p>建構子是一個特殊的方法，它在類別被實例化（物件被建立）時自動被呼叫。建構子通常用於初始化物件的屬性或進行一些初始設定。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">echo</span> <span class="s2">&#34;物件已被建立！&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$object</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyClass</span><span class="p">();</span> <span class="c1">// 輸出：物件已被建立！
</span></span></span></code></pre></div><h3 id="custom-methods">Custom Methods</h3>
<p>自訂方法是我們根據類別的需求自行定義的方法。其中的一個常見技巧是使用 <code>return $this</code>，這使得方法可以被鏈式呼叫（Method Chaining）。</p>
<p><strong>鏈式呼叫(Method Chaining)</strong> 指在同一個物件上連續呼叫多個方法，而不需要每次呼叫都賦值給一個變數。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Calculator</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span> <span class="nv">$result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="k">function</span> <span class="nf">add</span><span class="p">(</span><span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">result</span> <span class="o">+=</span> <span class="nv">$value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nv">$this</span><span class="p">;</span> <span class="c1">// 返回物件本身以便鏈式呼叫
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="k">function</span> <span class="nf">subtract</span><span class="p">(</span><span class="nv">$value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">result</span> <span class="o">-=</span> <span class="nv">$value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nv">$this</span><span class="p">;</span> <span class="c1">// 返回物件本身
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="k">function</span> <span class="nf">getResult</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$calculator</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Calculator</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nv">$result</span> <span class="o">=</span> <span class="nv">$calculator</span><span class="o">-&gt;</span><span class="na">add</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">subtract</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="o">-&gt;</span><span class="na">getResult</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">echo</span> <span class="nv">$result</span><span class="p">;</span> <span class="c1">// 輸出：5
</span></span></span></code></pre></div><p>在這個例子中，<code>add</code> 和 <code>subtract</code> 方法返回了物件本身 <code>$this</code>，這樣它們可以連續呼叫，而不需要每次呼叫都賦值給一個變數。</p>
<h2 id="建構子引數的推廣-constructor-property-promotion">建構子引數的推廣 (Constructor Property Promotion)</h2>
<p>在 PHP 8.0 及以上版本中，引入的新特性。</p>
<p>當使用建構子引數推廣之前，我們需要手動為每個類別的屬性指定建構子引數，然後在建構子中賦值。以下是一個使用前的範例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">User</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span> <span class="nx">string</span> <span class="nv">$name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span> <span class="nx">string</span> <span class="nv">$email</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span> <span class="o">?</span><span class="nx">string</span> <span class="nv">$phoneNumber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span><span class="nx">string</span> <span class="nv">$name</span><span class="p">,</span> <span class="nx">string</span> <span class="nv">$email</span><span class="p">,</span> <span class="o">?</span><span class="nx">string</span> <span class="nv">$phoneNumber</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">name</span> <span class="o">=</span> <span class="nv">$name</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">email</span> <span class="o">=</span> <span class="nv">$email</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="nv">$this</span><span class="o">-&gt;</span><span class="na">phoneNumber</span> <span class="o">=</span> <span class="nv">$phoneNumber</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 建立使用者物件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nv">$user</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">User</span><span class="p">(</span><span class="s1">&#39;John Doe&#39;</span><span class="p">,</span> <span class="s1">&#39;john@example.com&#39;</span><span class="p">,</span> <span class="s1">&#39;123-456-7890&#39;</span><span class="p">);</span>
</span></span></code></pre></div><p>在上面的範例中，我們需要手動宣告建構子的引數，然後再將這些引數賦值給類別的屬性。</p>
<p>使用建構子引數推廣後的範例：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">User</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">        <span class="k">private</span> <span class="nx">string</span> <span class="nv">$name</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="k">private</span> <span class="nx">string</span> <span class="nv">$email</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="k">private</span> <span class="o">?</span><span class="nx">string</span> <span class="nv">$phoneNumber</span> <span class="o">=</span> <span class="k">null</span>
</span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 建構子的內容
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 建立使用者物件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nv">$user</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">User</span><span class="p">(</span><span class="s1">&#39;John Doe&#39;</span><span class="p">,</span> <span class="s1">&#39;john@example.com&#39;</span><span class="p">,</span> <span class="s1">&#39;123-456-7890&#39;</span><span class="p">);</span>
</span></span></code></pre></div><p>在這個例子中，建構子的引數列表直接宣告瞭類別的屬性。<code>$name</code> 和 <code>$email</code> 屬性是必須的，而 <code>$phoneNumber</code> 屬性是可選的（使用 <code>?string</code> 表示可以為空）。在建構子中，不需要再手動賦值給這些屬性，PHP 會自動處理。這樣，我們可以簡化建構子的定義，使程式碼更加簡潔和易讀。</p>
<h2 id="存取修飾符-access-modifiers">存取修飾符 (Access Modifiers)</h2>
<h3 id="public公共">public（公共)</h3>
<p><code>public</code> 修飾符表示該成員(屬性或方法)在類別內外部均可被訪問。這意味著無論是在類別內部、子類別、還是外部程式碼中，都可以直接訪問這個成員，<strong>它是預設值</strong>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="nv">$publicProperty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="k">function</span> <span class="nf">publicMethod</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 可以被任何地方訪問
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="protected-受保護">protected (受保護)</h3>
<p><code>protected</code> 修飾符表示該成員只能在定義它的<code>類別內部</code>和<code>子類別</code>中被訪問。外部程式碼無法直接訪問受保護的成員。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">protected</span> <span class="nv">$protectedProperty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">protected</span> <span class="k">function</span> <span class="nf">protectedMethod</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 只能在類別內部和子類別中訪問
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="private私有">private（私有)</h3>
<p><code>private</code> 修飾符表示該成員<strong>指能</strong>在定義它的<code>類別內部</code>被訪問，對於外部程式碼和子類別都是不可見的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">private</span> <span class="nv">$privateProperty</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">private</span> <span class="k">function</span> <span class="nf">privateMethod</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 只能在類別內部訪問
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="null-safe-operator">Null-Safe Operator</h2>
<p>在 <code>PHP 8.0</code> 版本中，引入了 Null-Safe Operator（空安全運算子），也稱為 Null-Safe Operator（<code>?-&gt;</code>），它是一種簡化程式碼的語法糖，用於在操作可能為 null 的物件時避免產生錯誤。</p>
<p>在舊版本的 PHP 中，如果你試圖在一個可能為 null 的變數上呼叫方法或訪問屬性，你必須先檢查該變數是否為 null，以避免產生 Fatal Error。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">if</span> <span class="p">(</span><span class="nx">isset</span><span class="p">(</span><span class="nv">$object</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$value</span> <span class="o">=</span> <span class="nv">$object</span><span class="o">-&gt;</span><span class="na">getValue</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$value</span> <span class="o">=</span> <span class="k">null</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>使用 Null-Safe Operator，你可以將上面的程式碼簡化為：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="nv">$value</span> <span class="o">=</span> <span class="nv">$object</span><span class="o">?-&gt;</span><span class="na">getValue</span><span class="p">();</span>
</span></span></code></pre></div><p>這樣，如果<code>$object</code>為 null，表示式的結果將會是 null，而不會丟擲錯誤。<code>Null-Safe Operator 只能用於物件的方法呼叫和屬性訪問，不能用於陣列和函式呼叫</code>。這個語法糖使得處理可能為 null 的物件更加方便和簡潔。</p>
<p>這裡是一個使用 Null-Safe Operator 的例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="k">function</span> <span class="nf">getValue</span><span class="p">()</span><span class="o">:</span> <span class="o">?</span><span class="nx">string</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 返回一個可能為null的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="s2">&#34;Hello, World!&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$object</span> <span class="o">=</span> <span class="k">null</span><span class="p">;</span> <span class="c1">// 或者一個MyClass的實例
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// 使用Null-Safe Operator呼叫可能為null的物件方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nv">$value</span> <span class="o">=</span> <span class="nv">$object</span><span class="o">?-&gt;</span><span class="na">getValue</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">echo</span> <span class="nv">$value</span><span class="p">;</span> <span class="c1">// 輸出 &#34;Hello, World!&#34; 或者 null（如果$object為null的話）
</span></span></span></code></pre></div><p>在這個例子中，無論<code>$object</code>是一個 MyClass 的實例還是 null，都不會產生錯誤，因為 Null-Safe Operator 會自動處理 null 情況。</p>
<h2 id="namespace">Namespace</h2>
<p>在 PHP 中，名稱空間（Namespace）是一種用來解決在不同類別之間命名衝突的機制。名稱空間可以是可選的，但在大型應用程式中，良好的組織和結構是非常重要的。以下是有關 PHP 名稱空間的一些基本概念和最佳實踐：</p>
<p>在程式檔案的最前面，你可以使用<code>namespace</code>宣告定義一個名稱空間。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">declare</span><span class="p">(</span><span class="nx">strict_types</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">namespace</span> <span class="nx">APP</span><span class="p">;</span> <span class="c1">// after strict_types
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// class implementation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>如果你的應用程式需要更深的組織結構，你可以使用巢狀名稱空間（Nested Namespace）。例如，如果你有一個銀行相關的類別，你可以這樣定義：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="nx">APP\Bank</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">BankAccount</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// class implementation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></div><p>當你在不同的名稱空間中使用類別時，你可以使用<code>use</code>關鍵字。例如，如果你要使用<code>APP</code>名稱空間中的<code>Account</code>類別，你可以這樣做：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="c1"># method1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nv">$myAccount</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">App\Account</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># method2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">use</span> <span class="nx">APP\Account</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">$myAccount</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Account</span><span class="p">();</span>
</span></span></code></pre></div><p>在某些情況下(<strong>當前在 namespace APP 下</strong>)，你可能需要使用 global namespace 中的類別。你可以使用斜線（\）字首來表示全域性名稱空間。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">namespace</span> <span class="nx">App</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># method1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">new</span> <span class="nx">\DateTime</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># method2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">use</span> <span class="nx">DateTime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">DateTime</span><span class="p">();</span>
</span></span></code></pre></div><p>有時候，你可能會想要為一個長命名的類別使用別名（Alias）。這樣可以使你的程式碼更簡潔易讀。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">use</span> <span class="nx">DateTime</span> <span class="k">as</span> <span class="nx">DT</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">new</span> <span class="nx">DT</span><span class="p">();</span>
</span></span></code></pre></div><p>如果你需要引入多個名稱空間中的類別，你可以使用逗號（,）分隔它們。例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">use</span> <span class="nx">APP\Account</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">use</span> <span class="nx">APP\SocialMedia</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 改寫
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">use</span> <span class="nx">APP\</span><span class="p">{</span><span class="nx">Account</span><span class="p">,</span> <span class="nx">SocialMedia</span><span class="p">};</span>
</span></span></code></pre></div><p>使用名稱空間和<code>use</code>語句，讓你可以更好地組織你的程式碼，避免命名衝突，使程式碼更易於維護和擴充套件。</p>
<h2 id="autoloading-classes">Autoloading Classes</h2>
<p>使用自動載入機制（例如 <code>spl_autoload_register</code> 函式）主要是為了方便管理多個類別，特別是當每個類別都儲存在獨立的檔案中時。這樣，你可以根據類別的<code>名稱空間</code>和<code>類別名稱</code>來自動載入相應的檔案。</p>
<p>然而，<strong>如果在同一個檔案中既有類別定義又有函式定義</strong>，那麼最好還是在需要的時候手動引入這些檔案。這是因為自動載入機制主要是為了類別而設計的，而不是用來處理函式。如果在自動載入的過程中引入了一個檔案，裡面除了類別定義還包含其他程式碼（如函式定義），可能會導致不必要的程式碼複雜性和不易讀懂的程式碼。</p>
<p>因此，最佳的做法是：</p>
<ol>
<li>
<p><strong>將每個類別儲存在獨立的檔案中。</strong> 這樣可以使用自動載入機制，方便地根據類別的名稱空間和類別名稱來自動載入相應的檔案。</p>
</li>
<li>
<p><strong>如果檔案中既有類別定義又有函式定義，需要時手動引入。</strong> 如果檔案中有其他不屬於類別的程式碼（例如函式或常數），最好在需要使用這些程式碼的地方<strong>手動引入</strong>相應的檔案。這樣可以確保程式碼的可讀性和可維護性。</p>
</li>
</ol>
<p>以下是一個範例，演示瞭如何使用自動載入機制來載入類別，並在需要的時候手動引入檔案中的函式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="c1">// require_once &#39;APP/Account.php&#39;;
</span></span></span><span class="line"><span class="cl"><span class="c1">// require_once &#39;APP/SocialMedia.php&#39;;
</span></span></span><span class="line"><span class="cl"><span class="c1">// require_once &#39;APP/..&#39;;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">spl_autoload_register</span><span class="p">(</span><span class="k">function</span><span class="p">(</span><span class="nv">$class</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$formattedClass</span> <span class="o">=</span> <span class="nx">str_replace</span><span class="p">(</span><span class="s2">&#34;</span><span class="se">\\</span><span class="s2">&#34;</span><span class="p">,</span> <span class="s2">&#34;/&#34;</span><span class="p">,</span> <span class="nv">$class</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nv">$path</span> <span class="o">=</span> <span class="s2">&#34;</span><span class="si">{</span><span class="nv">$formattedClass</span><span class="si">}</span><span class="s2">.php&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">require_once</span> <span class="nv">$path</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">});</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用自動載入機制載入類別
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nv">$account</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">\APP\Account</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 手動引入檔案中的函式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">require_once</span> <span class="s1">&#39;path/to/file-with-functions.php&#39;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 現在你可以使用檔案中定義的函式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">myFunction</span><span class="p">();</span>
</span></span></code></pre></div><h2 id="常數-constants">常數 (Constants)</h2>
<p>在 PHP 中，常數是在類別中定義的不可改變的值，這些值在整個類別中都是固定的。在類別中定義常數使用 <code>const</code> 關鍵字，<strong>不可使用 <code>define()</code> 函式</strong>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Account</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="no">INTEREST_RATE</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 其他類別成員和方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 存取常數的方式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">echo</span> <span class="nx">Account</span><span class="o">::</span><span class="na">INTEREST_RATE</span><span class="p">;</span>
</span></span></code></pre></div><p>在這個範例中，<code>INTEREST_RATE</code> 是 <code>Account</code> 類別的常數，它的值不可更改，可以在整個應用程式中使用，提高了程式碼的可讀性和一致性。</p>
<h2 id="靜態成員-static-members">靜態成員 (Static Members)</h2>
<h3 id="靜態屬性-static-properties">靜態屬性 (Static Properties)</h3>
<p>靜態屬性是指在整個類別中共用的屬性，可以被所有實例共享。然而，靜態屬性的值可以被修改，因此在使用時需要小心 (<strong>能不要用就不要用</strong>)。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Account</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="k">static</span> <span class="nv">$count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="k">function</span> <span class="fm">__construct</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">self</span><span class="o">::</span><span class="nv">$count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">getCount</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">self</span><span class="o">::</span><span class="nv">$count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 使用靜態屬性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nv">$account1</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Account</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nv">$account2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Account</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">echo</span> <span class="nx">Account</span><span class="o">::</span><span class="nv">$count</span><span class="p">;</span> <span class="c1">// 輸出：2
</span></span></span></code></pre></div><p>在這個例子中，<code>$count</code> 是一個靜態屬性，用來記錄 <code>Account</code> 類別的實例數量。每次建立一個新的 <code>Account</code> 物件時，<code>$count</code> 的值會自動增加。</p>
<h3 id="靜態方法-static-methods">靜態方法 (Static Methods)</h3>
<p>靜態方法是可以在不建立類別實例的情況下直接呼叫的方法。靜態方法通常用於 utility 類別，這些方法不依賴於特定的實例，而是執行通用的任務。這搭配上前面提到的 <code>Autoloading Class</code> 方法時會相當方便。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-php" data-lang="php"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Utility</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">public</span> <span class="k">static</span> <span class="k">function</span> <span class="nf">calculateArea</span><span class="p">(</span><span class="nv">$radius</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">pi</span><span class="p">()</span> <span class="o">*</span> <span class="nv">$radius</span> <span class="o">*</span> <span class="nv">$radius</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 呼叫靜態方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nv">$area</span> <span class="o">=</span> <span class="nx">Utility</span><span class="o">::</span><span class="na">calculateArea</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 計算半徑為5的圓面積
</span></span></span></code></pre></div><p>在這個例子中，<code>calculateArea</code> 是一個靜態方法，可以直接透過 <code>Utility::calculateArea()</code> 的方式呼叫，而不需要建立 <code>Utility</code> 物件。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Design Patterns Explained - CH8</title>
      <link>https://blog2.cmwang.net/zh/posts/2017/01/design-patterns-explained-ch8/</link>
      <pubDate>Sat, 21 Jan 2017 20:12:53 +0000</pubDate>
      <guid>https://blog2.cmwang.net/zh/posts/2017/01/design-patterns-explained-ch8/</guid>
      <description>&lt;h1 id=&#34;expanding-our-horizons&#34;&gt;Expanding Our Horizons&lt;/h1&gt;
&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Object&lt;/li&gt;
&lt;li&gt;Encapsulation&lt;/li&gt;
&lt;li&gt;Inheritance&lt;/li&gt;
&lt;li&gt;Handling variation&lt;/li&gt;
&lt;li&gt;Commonality and variability analysis&lt;/li&gt;
&lt;li&gt;Abstract class and its derived classes&lt;/li&gt;
&lt;/ul&gt;</description>
      <content:encoded><![CDATA[<h1 id="expanding-our-horizons">Expanding Our Horizons</h1>
<h2 id="overview">Overview</h2>
<ul>
<li>Object</li>
<li>Encapsulation</li>
<li>Inheritance</li>
<li>Handling variation</li>
<li>Commonality and variability analysis</li>
<li>Abstract class and its derived classes</li>
</ul>
<h2 id="objects-traditional-view-and-new-view">Objects: Traditional view and new view</h2>
<h3 id="traditional-view">Traditional View</h3>
<ul>
<li>Data with methods - <strong>smart data</strong></li>
<li>too narrow from <strong>implementation</strong> perspective</li>
</ul>
<h3 id="broad-view">Broad View</h3>
<ul>
<li>From <strong>conceptual</strong> perspective</li>
<li>an object is an <em>entity that has responsibilities</em> (責任), these responsibilities define the behavior of the object. Or an <em>entity that has specific behavior</em> (特定行為).</li>
</ul>
<h2 id="focus-on-intentionmotivation-not-implementation">Focus on intention/motivation not implementation</h2>
<p>This view enables us to build software in two steps:</p>
<ol>
<li>Make a preliminary design without worrying about all the details involved.</li>
<li>Implement the design.</li>
</ol>
<p>The reason this works is that we only have to focus on the object’s <strong>public interface</strong> — the communication window through which I ask the object to do something.</p>
<p>Hiding implementations behind interfaces essentially <strong>decouples</strong> them from the using objects.</p>
<hr>
<h2 id="encapsulation-traditional-view-and-new-view">Encapsulation: Traditional view and new view</h2>
<h3 id="traditional-view-1">Traditional View</h3>
<ul>
<li>data hiding</li>
</ul>
<h3 id="broad-view-1">Broad View</h3>
<ul>
<li><strong>any kind of hiding</strong>
<ul>
<li>Implementations (data, methods..)</li>
<li><strong>Drived</strong> classes (<strong>Encapsulation of type</strong> is achieved when there is an <em>abstract class</em> with derivations (or an interface with implementations) that are used <em>polymorphically</em>)</li>
<li>Design details</li>
<li>Instantiation rules (ex. creational patterns)</li>
</ul>
</li>
</ul>
<h2 id="advantage">Advantage</h2>
<p>It gives us a better way to split up (decompose) our programs. The <strong>encapsulating layers</strong> become the <strong>interfaces</strong> we design to. (封裝層成為設計需要遵循的介面)</p>
<p>By encapsulating different kinds of subclasses (<strong>encapsulation of type</strong>), we can add new ones without changing any of the client programs using them. (<em>GoF typically means when they mention encapsulation</em>)</p>
<hr>
<h2 id="inheritance">Inheritance</h2>
<h3 id="traditional-view-2">Traditional View</h3>
<ul>
<li><strong>reuse</strong> of classes</li>
<li>achived by creating classes and then deriving new (<em>spcialized</em>) classes bases on these base (<em>generalized</em>) classes</li>
</ul>
<h3 id="broad-view-2">Broad View</h3>
<ul>
<li>using inheritance for specialization, however
<ul>
<li>can cause weak cohesion</li>
<li>reduces possibility of reuse</li>
<li>does not scale well with variation</li>
</ul>
</li>
<li><em>to classify classes as things that behave the same way</em>. (<strong>placeholder</strong>)</li>
</ul>
<hr>
<h2 id="find-what-is-varying-and-encapsulate-it">Find What Is Varying and Encapsulate It</h2>
<blockquote>
<p>Consider <strong>what</strong> should be variable in your design. This approach is the opposite of focusing on the <strong>cause</strong> of redesign. Instead of considering what might force a change to a design, consider what you want to be <strong><em>able</em></strong> to change without redesign. The focus here is on <strong><em>encapsulating the concept that varies</em></strong>, a theme of many design patterns.
&ndash; GoF, Design Patterns</p>
</blockquote>
<hr>
<h2 id="more-about-gofs-encapsulation">More about GoF&rsquo;s Encapsulation</h2>
<ul>
<li>Design Patterns use inheritance to classify variations in behaviors.</li>
<li>Hiding classes with an abstract class or interface — <strong>type encapsulation</strong>.</li>
<li>Containing a reference of this <em>abstract class</em> or <em>interface</em> type (aggregation) <strong>hides</strong> these <em>derived classes</em> that represent <strong>variations</strong> in behavior.</li>
<li>In effect, many design patterns <em>use encapsulation to create layers</em> between objects.</li>
</ul>
<hr>
<h2 id="containing-variation-in-data-vs-containing-variation-in-behavior">Containing variation in data vs containing variation in behavior</h2>
<h3 id="handling-variation-in-data">Handling variation in data</h3>
<ul>
<li>Have a data member that tells me what type of movement my object has.</li>
<li>Have two different types of <strong>Animals</strong> (both derived from the base <strong>Animal</strong> class) — one for walking and one for flying.</li>
</ul>
<h3 id="handling-variation-in-behavior-with-objects">Handling variation in behavior with objects</h3>
<p>Using objects to contain variation in attributes and using objects to contain variation in behavior are very similar. Don&rsquo;t afraid.</p>
<hr>
<h2 id="commonality-and-variability">Commonality and Variability</h2>
<p>Identify <strong>where</strong> things vary (commonality analysis) and then identify <strong>how</strong> they vary (variability analysis).</p>
<p><strong>Commonality analysis</strong> is the search for common elements that helps us understand how family members are the same.</p>
<p><strong>Variability analysis</strong> reveals how family members vary. Variability only makes sense within a given commonality.</p>
<p>Ex. Whiteboard marker, pencil, ballpoint pen</p>
<ul>
<li>Commonality: writing instrument</li>
<li>Variability: material to write, shape..</li>
</ul>
<h2 id="commonality-and-variability-and-abstract-class">Commonality and Variability and Abstract class</h2>
<p><strong>Commonality analysis</strong> seeks structure that is unlikely to change over time, while <strong>variability analysis</strong> captures structure that is likely to change. <strong><em>Variability analysis makes sense only in terms of the context defined by the associated commonality analysis</em></strong>.
In other words, if variations are the specific concrete cases in the domain, commonality defines the concepts in the domain that tie them together. The <strong><em>common concepts</em></strong> will be represented by <strong>abstract classes</strong>. The <strong><em>variations</em></strong> found by variability analysis will be implemented by the <strong>concrete classes</strong>.</p>
<h2 id="relationship-between-commonality-and-variability-perspectives-and-abstract-classes">Relationship between Commonality and Variability, perspectives, and abstract classes</h2>
<p><img loading="lazy" src="relationship.png" alt="relationship"  />
</p>
<hr>
<h2 id="benefits-of-using-abstract-classes-for-specialization">Benefits of using abstract classes for specialization</h2>
<p><img loading="lazy" src="benefits.png" alt="benefits"  />
</p>
<hr>
<h2 id="two-step-procedure-for-design">Two-Step Procedure for Design</h2>
<p>Ask yourself:</p>
<ul>
<li>When defining an <strong>abstract class</strong> (commonality):
<ul>
<li>What <strong>interface</strong> is needed to handle all the responsibilities (core concepts from the conceptual perspective) of this class?</li>
</ul>
</li>
<li>When defining <strong>derived classes</strong>:
<ul>
<li>Given this particular implementation (this <strong>variation</strong>), how can I implement it (variation) with the given specification?</li>
</ul>
</li>
</ul>
<hr>
<h2 id="take-away">Take away</h2>
<p>Think object-oriented in a broad way.</p>
<ul>
<li>Object: an <em>entity that has responsibilities (specific behavior)</em></li>
<li>Encapsulation: <strong>any</strong> kind of <strong>hiding</strong> (instantiation rule, type..)</li>
<li>Inheritance: use for <strong>specialization</strong> and <em>classify classes as things that behave the same way</em>.</li>
</ul>
<p><strong>Find what is varying and encapsulate it</strong> (in behavior).</p>
<p>Commonality, variability and abstract class: use inheritance to classify variations in behaviors.</p>]]></content:encoded>
    </item>
    <item>
      <title>Design Patterns Explained - CH1</title>
      <link>https://blog2.cmwang.net/zh/posts/2017/01/design-patterns-explained-ch1/</link>
      <pubDate>Fri, 20 Jan 2017 18:12:53 +0000</pubDate>
      <guid>https://blog2.cmwang.net/zh/posts/2017/01/design-patterns-explained-ch1/</guid>
      <description>&lt;h1 id=&#34;object-oriented-paradigm&#34;&gt;Object-Oriented Paradigm&lt;/h1&gt;
&lt;p&gt;Purpose: Explain why object-oriented paradigm over functional decomposition.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h1 id="object-oriented-paradigm">Object-Oriented Paradigm</h1>
<p>Purpose: Explain why object-oriented paradigm over functional decomposition.</p>
<h2 id="naive-problem">Naive Problem</h2>
<p>If I were to give you the task of writing code to access a description of shapes that were stored in a database and then display them.</p>
<p>如果給你一個任務，要編寫一段程式，存取在資料庫中儲存的形狀描述，然後將它顯示出來。</p>
<h2 id="structural-programming-thinking---possible-steps">Structural Programming thinking - possible steps</h2>
<ol>
<li>Locate the list of shapes in the database. (在資料庫中找到形狀清單)。</li>
<li>Open up the list of shapes. (打開形狀清單)。</li>
<li>Sort the list according to some rules. (依照某種規則將清單排序)。</li>
<li>Display the individual shapes on the monitor. (在螢幕上顯示各種形狀)。</li>
</ol>
<h2 id="functional-decomposition-功能分解">Functional Decomposition (功能分解)</h2>
<p>4a. Identify the type of shape. (識別形狀的類型)。
4b. Get the location of the shape. (獲取形狀的位置)。</p>
<p>4c. Call the appropriate function that will display the shape, giving it the shape’s location. (以形狀的位置為參數，呼叫顯示形狀的 Function)。</p>
<h2 id="functional-decomposition-的挑戰">Functional Decomposition 的挑戰</h2>
<ol>
<li>它通常會導致一個*<strong>*主**<strong>程式負責控制子程式(subprograms)。 這使得主程式所承受的</strong>責任</strong>太多了：要協調各 subprograms，還要控制他們的順序 (Why not delegation?)。 <strong>&laquo;上帝物件：能者多勞&raquo;</strong></li>
<li>如果將實作各步驟的所有邏輯都放在一個大 Function 或大 module 的話，則這些步驟的實質性變化，都必須對這個 Function 或 module 進行修改。 <strong>&laquo;因應變化的能力差&raquo;</strong></li>
</ol>
<h2 id="討論">討論</h2>
<ol>
<li>需求總是在改變 <strong>(不變的真理)</strong>。</li>
<li>我們可能不知道會發生什麼變化，但我們能夠猜到哪裡會變化。<strong>(OO 最大的優點之一，就是可以封裝這些變化區域)。</strong></li>
<li>與其抱怨需要總是改變，不如改變開發流程，有效的因應變化。</li>
</ol>
<h2 id="dealing-with-changes-functional-decomposition">Dealing with Changes: Functional Decomposition</h2>
<p>4c. Call the appropriate function that will display the shape, giving it the shape’s location. (以形狀的位置為參數，呼叫顯示形狀的 Function)。</p>
<p><strong>Using Modularity to Contain Variation</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nl">function</span><span class="p">:</span> <span class="n">display</span> <span class="n">shape</span>
</span></span><span class="line"><span class="cl"><span class="nl">input</span><span class="p">:</span> <span class="n">type</span> <span class="n">of</span> <span class="n">shape</span><span class="p">,</span> <span class="n">description</span> <span class="n">of</span> <span class="n">shape</span>
</span></span><span class="line"><span class="cl"><span class="nl">action</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">   <span class="k">switch</span> <span class="p">(</span><span class="n">type</span> <span class="n">of</span> <span class="n">shape</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nl">square</span><span class="p">:</span> <span class="n">put</span> <span class="n">display</span> <span class="n">function</span> <span class="k">for</span> <span class="n">square</span> <span class="n">here</span>
</span></span><span class="line"><span class="cl">      <span class="k">case</span> <span class="nl">circle</span><span class="p">:</span> <span class="n">put</span> <span class="n">display</span> <span class="n">function</span> <span class="k">for</span> <span class="n">circle</span> <span class="n">here</span>
</span></span></code></pre></div><h2 id="討論-1">討論</h2>
<ol>
<li>如果要顯示一個新的形狀(例如三角形)，我可能只需要改這個模組(希望是)。</li>
<li>這個模組的輸入是 type of shape, description of shape，如果今天使用不同方式提供輸入(例如 array of points 或其他方式)，該怎麼辦？</li>
</ol>
<hr>
<h2 id="functional-decomposition-兩個可能的問題">Functional Decomposition 兩個可能的問題</h2>
<ol>
<li><strong>Weak cohesion</strong> (Cohesion refers to how “closely the operations in a routine are related; cohesion as <strong>clarity</strong> because the more that operations are related in a routine (or a class), the easier it is to understand things.)</li>
<li><strong>Tight Coupling</strong> (Coupling refers to “the strength of a connection between two routines. Coupling is a complement to cohesion.)</li>
</ol>
<p>The goal is to create routines with internal integrity <strong>(strong cohesion)</strong> and small, direct, visible, and flexible relations to other routines <strong>(loose coupling)</strong>.</p>
<hr>
<h2 id="從日常生活借鏡">從日常生活借鏡</h2>
<p>You are an instructor at a conference. People in your class have another class to attend following yours, but don’t know where it is located. One of your responsibilities is to make sure everyone knows how to get to the next class.</p>
<p>你的責任是確保大家知道怎麼去到下一堂課的位置。</p>
<hr>
<h2 id="可能的步驟">可能的步驟</h2>
<ol>
<li>Get list of people in the class.</li>
<li>For each person on this list, do the following:
<ol>
<li>Find the next class he or she is taking.</li>
<li>Find the location of that class.</li>
<li>Find the way to get from your classroom to the person’s next class.</li>
<li>Tell the person how to get to his or her next class.</li>
</ol>
</li>
</ol>
<hr>
<h2 id="所以你可能需要這麼做">所以你可能需要這麼做</h2>
<ol>
<li>A way of getting the list of people in the class.</li>
<li>A way of getting the schedule for each person in the class.</li>
<li>A program that gives someone directions from your classrom to any other classroom.</li>
<li>A control program that works for each person in the class and does the reuqired steps for each person.</li>
</ol>
<hr>
<h2 id="不-你應該會這樣做">不! 你應該會這樣做</h2>
<p>你可能會把從這個教室到其他教室的路線貼出來，然後告訴所有人：我們已經將下一堂課的地點和其他教室的位置都貼在後面了，請根據它找到你們下一堂課的教室。</p>
<p>You would probably post directions to go from this classroom to the other classrooms and then tell everyone in the class, <strong><em>I have posted the locations of the classes following this in the back of the room, as well as the locations of the other classrooms. Please use them to go to your next classroom.</em></strong></p>
<hr>
<h2 id="兩種策略的差別">兩種策略的差別</h2>
<ol>
<li>Giving <strong>explicit directions</strong> to everyone.</li>
<li>Giving <strong>general instructions</strong> and then expect the each person will figure out how to do the task individually. <strong>(責任轉移 delegation)</strong></li>
</ol>
<hr>
<h2 id="需求又改變了">需求又改變了</h2>
<p>如果我被告知，需要給擔任助教工作的學生一些特殊指示。他們可能需要在下一堂課前收集本堂課學生的評價，並且交到辦公室。</p>
<ol>
<li>第一種方式，不得不改控制程式，<strong>區別研究生跟大學生</strong>，然後給研究生特別的指示。</li>
<li>第二種方式，只需要為研究生再編寫一個程式，但控制程式仍然只需要說: <strong>找到你們的下一堂教室</strong>。</li>
</ol>
<hr>
<h2 id="為什麼有這麼大的差異">為什麼有這麼大的差異</h2>
<ol>
<li>人們對自己的行為負責，而不再由一個中央控制程式負責決定。</li>
<li>控制程式可以與不同類型的學生交流(大學生或研究生)。</li>
<li>控制程式不需要知道學生從這個教室到下一個教室可能需要採取的任何特殊步驟。</li>
</ol>
<hr>
<h2 id="軟體開發的三種視角">軟體開發的三種視角</h2>
<ol>
<li><strong>Conceptual:</strong> 表示 domain concepts，不管如何實作。回答這個問題：<strong>What am I responsibile for?</strong></li>
<li><strong>Specification:</strong> 關注軟體的 interface，但還是不管如何實作。回答這個問題：<strong>How am I used?</strong></li>
<li><strong>Implementation:</strong> 我們都很熟。回答這個問題： <strong>How do I fulfill my responsibilities?&quot;</strong></li>
</ol>
<hr>
<h2 id="不同視角的用途">不同視角的用途</h2>
<p>概念層次上的溝通：你告訴學生的是「你要他們怎麼做」，而不是「如何去做」。 (you are telling people what you want, not how to do it.)</p>
<p>在概念層次上交流，而在另一層次(實作)上執行，這樣講師就不需要知道具體的實作細節。只需要一般性，概念性的知道即可。</p>
<p><strong>效力</strong>：只要概念不變，請求者與<strong>實作細節的變化</strong>就被隔離開來。</p>
<hr>
<h2 id="object-oriented-paradigm-1">Object-Oriented Paradigm</h2>
<p>使用物件的優點在於，可以定義物件負責自己的事務。</p>
<p><img loading="lazy" src="resp.png" alt="resp"  />
</p>
<hr>
<h2 id="討論-2">討論</h2>
<p>The <strong>objects</strong> were identified by looking at the entities in the <strong>problem domain</strong>. I identified the <strong>responsibilities (or methods)</strong> for each object by looking at what these entities <strong>need to do</strong>.</p>
<p>&ndash;
☆☆☆ 理解物件的最佳方式 ☆☆☆
<strong>將其看為具有責任的東西</strong>。物件應該自己負責自己，而且應該清楚地定義責任。</p>
<hr>
<h2 id="apply-fowlers-perspectives">Apply Fowler&rsquo;s Perspectives</h2>
<ul>
<li>At the <strong>conceptual</strong> level, an object is a set of responsibilities. (一組責任)</li>
<li>At the <strong>specification</strong> level, an object is a set of methods (behaviors) that can be invoked by other objects or by itself. (一組行為)</li>
<li>At the <strong>implementation</strong> level, an object is code and data and computational interactions between them.</li>
</ul>
<hr>
<h2 id="object-oriented-approach">Object-Oriented Approach</h2>
<ol>
<li>Start the control program.</li>
<li>Instantiate the collection of students in the classroom.</li>
<li>Tell the collection to have the students go to their next class.</li>
<li>The collection tells each student to go to his or her next class.</li>
<li>Each student:
<ol>
<li>Finds where his next class is.</li>
<li>Determines how to get there.</li>
<li>Goes there.</li>
</ol>
</li>
<li>Done.</li>
</ol>
<hr>
<h2 id="abstract-and-polymorphism">Abstract and Polymorphism</h2>
<ul>
<li>Student abstract class, GraduageStudent and RegularStudent classes.</li>
<li>Abstract classes define what other, related, classes can do. Abstract classes act as <strong>placeholders</strong> for other classes.</li>
<li>Collection 只需要處理 Student 這個 Concept (Abstract)，每一種 Student 都可以按照自己的方式實作功能 (Concrete)。</li>
<li>當我們透過抽象參考，概念性的要求物件做什麼時，將得到不同的行為，具體行為取決於 Derived Class 的實作。<strong>(Polymorphism)</strong></li>
</ul>
<hr>
<h2 id="回到一開始的問題">回到一開始的問題</h2>
<ol>
<li>Locate the list of shapes in the database. (在資料庫中找到形狀清單)。</li>
<li>Open up the list of shapes. (打開形狀清單)。</li>
<li>Sort the list according to some rules. (依照某種規則將清單排序)。</li>
<li>Display the individual shapes on the monitor. (在螢幕上顯示各種形狀)。</li>
</ol>
<hr>
<h2 id="object-oriented-approach-12">Object-Oriented Approach (1/2)</h2>
<p><img loading="lazy" src="resp2.png" alt="esp2.png"  />
</p>
<hr>
<h2 id="object-oriented-approach-22">Object-Oriented Approach (2/2)</h2>
<ol>
<li>主程式建立一個 <em>ShapeDataBase</em> 物件。</li>
<li>主程式要求 database object 找到我感興趣的一組形狀，並且 instantiate 一個保存這些形狀的 collection 物件.</li>
<li>主程式要求 Collection 物件排序所存放的形狀。</li>
<li>主程式要求 Collection 物件顯示形狀。</li>
<li>Collection 物件要求所存放的每個形狀顯示自己。</li>
<li>每個形狀根據形狀種類顯示自己。</li>
</ol>
<hr>
<h2 id="需求又改變了-1">需求又改變了</h2>
<ul>
<li>
<p>增加新的形狀 (三角形)</p>
<ol>
<li>增加一個新的三角形 Concrete Class</li>
<li>在此 Derived Class 實作自己的顯示方法。</li>
</ol>
</li>
<li>
<p>更改排序方式</p>
<ol>
<li>修改 Collection 的 Sorting algorithm</li>
</ol>
</li>
</ul>
<p><strong>結果</strong>：The object-oriented approach has limited the impact of <strong>changing</strong> requirements.</p>
<hr>
<h2 id="封裝的優點">封裝的優點</h2>
<ol>
<li>使用更容易，因為使用者不再需要擔心實作問題</li>
<li>可以在不考慮呼叫者的情況下修改實作 (因為它一開始就不知道物件怎麼實作的 depend on interface, not implementation)</li>
<li>The internals of an object are unknown to other objects. (封裝使物件內部行為的變化對其他物件變得透明了 <strong>&lt;不可見&gt;</strong>)。</li>
</ol>
<hr>
<h2 id="take-away">Take away</h2>
<ol>
<li>將物件看為<strong>具有責任</strong>的東西。物件應該自己負責自己，而且應該清楚地定義責任。</li>
<li>物件真正的威力不在於繼承，而是來自於<strong>封裝行為</strong>(採取更廣義的封裝定義)。</li>
<li>OO 最大的優點之一，就是可以<strong>封裝</strong>這些<strong>變化區域</strong>。</li>
<li>抽象與責任轉嫁的好處 (placeholder and delegation)。</li>
<li>三種視角的應用 (在抽象層次上溝通，在實作層次上執行)。</li>
</ol>]]></content:encoded>
    </item>
  </channel>
</rss>
